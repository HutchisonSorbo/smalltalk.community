[{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543524","pull_request_review_id":3714262843,"id":2734543524,"node_id":"PRRC_kwDOQmxOz86i_dKk","diff_hunk":"@@ -888,3 +888,184 @@ export class DatabaseStorage implements IStorage {\n   private _buildGigFilters(filters?: GigFilters) {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n+\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }\n+\n+  async getGigsByMusician(musicianId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.musicianId, musicianId)).orderBy(gigs.date);\n+  }\n+\n+  // Notifications\n+  async getNotifications(userId: string): Promise<Notification[]> {\n+    return db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));\n+  }\n+\n+  async getUnreadNotificationCount(userId: string): Promise<number> {\n+    const result = await db.select({ count: sql<number>`count(*)::int` }).from(notifications).where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));\n+    return result[0]?.count || 0;\n+  }\n+\n+  async createNotification(notification: InsertNotification): Promise<Notification> {\n+    const [created] = await db.insert(notifications).values(notification).returning();\n+    return created;\n+  }\n+\n+  async markNotificationAsRead(id: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));\n+  }\n+\n+  async markAllNotificationsAsRead(userId: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.userId, userId));\n+  }\n+\n+  // Contact Requests\n+  async createContactRequest(request: InsertContactRequest): Promise<ContactRequest> {\n+    const [created] = await db.insert(contactRequests).values(request).returning();\n+    return created;\n+  }\n+\n+  async getContactRequest(requesterId: string, recipientId: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(and(eq(contactRequests.requesterId, requesterId), eq(contactRequests.recipientId, recipientId)));\n+    return request;\n+  }\n+\n+  async getContactRequestById(id: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(eq(contactRequests.id, id));\n+    return request;\n+  }\n+  \n+  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+  }","path":"server/storage.ts","commit_id":"b8781ca50667611df17c5261d31707dc6ec8f7d8","original_commit_id":"b8781ca50667611df17c5261d31707dc6ec8f7d8","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü° Minor_\n\n<details>\n<summary>üß© Analysis chain</summary>\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# First, let's find the schema definition for contactRequests\nfind . -type f \\( -name \"*.ts\" -o -name \"*.tsx\" \\) | xargs grep -l \"contactRequests\\|ContactRequest\" | head -20\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 480\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Search for the schema definition of contactRequests table\nrg -n \"contactRequests|ContactRequest\" --type ts -B 3 -A 10 | head -150\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 9733\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Look for status enum or type definitions related to contact requests\nrg -n \"VALID_STATUSES|status.*pending|status.*accepted|status.*rejected\" --type ts -B 2 -A 2\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 16769\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Check the full context of updateContactRequestStatus and surrounding code\ncat -n server/storage.ts | sed -n '950,975p'\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 1382\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Check the contact request respond route to see what status values are used\ncat -n app/local-music-network/api/contact-requests/[id]/respond/route.ts | head -60\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 2943\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Search for all calls to updateContactRequestStatus\nrg -n \"updateContactRequestStatus\" --type ts -B 2 -A 2\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 1388\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Check for all places where contactRequests status is modified\nrg -n \"contactRequests.*status|status.*contactRequests\" --type ts -B 2 -A 2\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 365\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Check if there are any other API routes or methods that might call updateContactRequestStatus\nrg -n \"updateContactRequestStatus\\|contact-requests\\|contactRequests\" app/local-music-network/api/ --type ts -l\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 60\n\n---\n\nüèÅ Script executed:\n\n```shell\n#!/bin/bash\n# Verify consistent use of \"declined\" vs \"rejected\" for contact request status\nrg -n \"declined|rejected\" app/local-music-network --type ts -B 1 -A 1 | grep -i \"contact\\|status\" -A 1 -B 1\n```\n\nRepository: HutchisonSorbo/smalltalk.community\n\nLength of output: 1659\n\n---\n\n\n\n</details>\n\n**Use a union type for the `status` parameter to enforce type safety.**\n\nThe `status` parameter should be constrained to valid values. While the API route validates before calling this method, using a union type at the method level would provide better type safety and prevent future misuse. The valid statuses are 'pending', 'accepted', and 'declined'.\n\n<details>\n<summary>üîß Suggested fix</summary>\n\n```diff\n+ type ContactRequestStatus = 'pending' | 'accepted' | 'declined';\n+\n- async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+ async updateContactRequestStatus(id: string, status: ContactRequestStatus): Promise<void> {\n    await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n  }\n```\n</details>\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  type ContactRequestStatus = 'pending' | 'accepted' | 'declined';\n\n  async updateContactRequestStatus(id: string, status: ContactRequestStatus): Promise<void> {\n      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 967 - 969, The updateContactRequestStatus\nfunction currently accepts status: string which allows invalid values; change\nits signature to accept a union type status: 'pending' | 'accepted' | 'declined'\nand update any callers to pass one of these literal values (or cast/validate\nbefore calling) so the DB update line await db.update(contactRequests).set({\nstatus }).where(eq(contactRequests.id, id)); still works but now benefits from\ncompile-time type safety in updateContactRequestStatus.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:ocelot -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T02:03:08Z","updated_at":"2026-01-28T02:03:08Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/89#discussion_r2734543524","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/89","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543524"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/89#discussion_r2734543524"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/89"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543524/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":967,"original_start_line":967,"start_side":"RIGHT","line":969,"original_line":969,"side":"RIGHT","author_association":"NONE","original_position":82,"position":82,"subject_type":"line"},{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543526","pull_request_review_id":3714262843,"id":2734543526,"node_id":"PRRC_kwDOQmxOz86i_dKm","diff_hunk":"@@ -888,3 +888,184 @@ export class DatabaseStorage implements IStorage {\n   private _buildGigFilters(filters?: GigFilters) {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n+\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }\n+\n+  async getGigsByMusician(musicianId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.musicianId, musicianId)).orderBy(gigs.date);\n+  }\n+\n+  // Notifications\n+  async getNotifications(userId: string): Promise<Notification[]> {\n+    return db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));\n+  }\n+\n+  async getUnreadNotificationCount(userId: string): Promise<number> {\n+    const result = await db.select({ count: sql<number>`count(*)::int` }).from(notifications).where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));\n+    return result[0]?.count || 0;\n+  }\n+\n+  async createNotification(notification: InsertNotification): Promise<Notification> {\n+    const [created] = await db.insert(notifications).values(notification).returning();\n+    return created;\n+  }\n+\n+  async markNotificationAsRead(id: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));\n+  }\n+\n+  async markAllNotificationsAsRead(userId: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.userId, userId));\n+  }\n+\n+  // Contact Requests\n+  async createContactRequest(request: InsertContactRequest): Promise<ContactRequest> {\n+    const [created] = await db.insert(contactRequests).values(request).returning();\n+    return created;\n+  }\n+\n+  async getContactRequest(requesterId: string, recipientId: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(and(eq(contactRequests.requesterId, requesterId), eq(contactRequests.recipientId, recipientId)));\n+    return request;\n+  }\n+\n+  async getContactRequestById(id: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(eq(contactRequests.id, id));\n+    return request;\n+  }\n+  \n+  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+  }\n+\n+  // Security\n+  async checkRateLimit(userId: string, type: string, limit: number, windowSeconds: number): Promise<boolean> {\n+    const now = new Date();\n+    const windowStart = new Date(now.getTime() - windowSeconds * 1000);\n+\n+    const [record] = await db\n+      .insert(rateLimits)\n+      .values({\n+        userId,\n+        type,\n+        hits: 1,\n+        windowStart: now,\n+      })\n+      .onConflictDoUpdate({\n+        target: [rateLimits.userId, rateLimits.type],\n+        set: {\n+          hits: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.hits + 1 ELSE 1 END`,\n+          windowStart: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.window_start ELSE ${now} END`,\n+        },\n+      })\n+      .returning();\n+\n+    return record.hits <= limit;\n+  }\n+\n+  // Reports\n+  async createReport(report: InsertReport): Promise<Report> {\n+    const [created] = await db.insert(reports).values(report).returning();\n+    return created;\n+  }\n+\n+  // Admin/System\n+  async migrateUserId(oldId: string, newId: string): Promise<void> {\n+    console.warn(`Migrating user ${oldId} to ${newId} - Not fully implemented`);\n+  }","path":"server/storage.ts","commit_id":"b8781ca50667611df17c5261d31707dc6ec8f7d8","original_commit_id":"b8781ca50667611df17c5261d31707dc6ec8f7d8","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Stub method could cause silent failures in production.**\n\nThis method only logs a warning but doesn't perform any actual migration. Callers expecting migration to occur will experience silent failures leading to potential data inconsistency. Either implement the migration logic or throw an explicit error.\n\n\n<details>\n<summary>üîß Suggested fix - throw error until implemented</summary>\n\n```diff\n  async migrateUserId(oldId: string, newId: string): Promise<void> {\n-   console.warn(`Migrating user ${oldId} to ${newId} - Not fully implemented`);\n+   throw new Error(`migrateUserId is not implemented. Cannot migrate ${oldId} to ${newId}`);\n  }\n```\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 1002 - 1005, The migrateUserId stub\n(migrateUserId) currently only logs a warning and can cause silent failures;\nupdate it to either implement full migration logic across all places user IDs\nare stored (e.g., users collection/rows, sessions/auth tokens, messages,\nfiles/attachments, subscriptions/ACLs, references and any cache/index entries)\nensuring atomicity/consistency, or if you can‚Äôt implement it now, replace the\nconsole.warn with an explicit thrown error (e.g., throw new Error(\"migrateUserId\nnot implemented\")) so callers fail loudly; locate and modify the async\nmigrateUserId(oldId: string, newId: string): Promise<void> method to apply the\nchosen fix.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:ocelot -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T02:03:08Z","updated_at":"2026-01-28T02:03:09Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/89#discussion_r2734543526","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/89","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543526"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/89#discussion_r2734543526"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/89"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543526/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":1002,"original_start_line":1002,"start_side":"RIGHT","line":1005,"original_line":1005,"side":"RIGHT","author_association":"NONE","original_position":118,"position":118,"subject_type":"line"},{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543529","pull_request_review_id":3714262843,"id":2734543529,"node_id":"PRRC_kwDOQmxOz86i_dKp","diff_hunk":"@@ -888,3 +888,184 @@ export class DatabaseStorage implements IStorage {\n   private _buildGigFilters(filters?: GigFilters) {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n+\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }\n+\n+  async getGigsByMusician(musicianId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.musicianId, musicianId)).orderBy(gigs.date);\n+  }\n+\n+  // Notifications\n+  async getNotifications(userId: string): Promise<Notification[]> {\n+    return db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));\n+  }\n+\n+  async getUnreadNotificationCount(userId: string): Promise<number> {\n+    const result = await db.select({ count: sql<number>`count(*)::int` }).from(notifications).where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));\n+    return result[0]?.count || 0;\n+  }\n+\n+  async createNotification(notification: InsertNotification): Promise<Notification> {\n+    const [created] = await db.insert(notifications).values(notification).returning();\n+    return created;\n+  }\n+\n+  async markNotificationAsRead(id: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));\n+  }\n+\n+  async markAllNotificationsAsRead(userId: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.userId, userId));\n+  }\n+\n+  // Contact Requests\n+  async createContactRequest(request: InsertContactRequest): Promise<ContactRequest> {\n+    const [created] = await db.insert(contactRequests).values(request).returning();\n+    return created;\n+  }\n+\n+  async getContactRequest(requesterId: string, recipientId: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(and(eq(contactRequests.requesterId, requesterId), eq(contactRequests.recipientId, recipientId)));\n+    return request;\n+  }\n+\n+  async getContactRequestById(id: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(eq(contactRequests.id, id));\n+    return request;\n+  }\n+  \n+  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+  }\n+\n+  // Security\n+  async checkRateLimit(userId: string, type: string, limit: number, windowSeconds: number): Promise<boolean> {\n+    const now = new Date();\n+    const windowStart = new Date(now.getTime() - windowSeconds * 1000);\n+\n+    const [record] = await db\n+      .insert(rateLimits)\n+      .values({\n+        userId,\n+        type,\n+        hits: 1,\n+        windowStart: now,\n+      })\n+      .onConflictDoUpdate({\n+        target: [rateLimits.userId, rateLimits.type],\n+        set: {\n+          hits: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.hits + 1 ELSE 1 END`,\n+          windowStart: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.window_start ELSE ${now} END`,\n+        },\n+      })\n+      .returning();\n+\n+    return record.hits <= limit;\n+  }\n+\n+  // Reports\n+  async createReport(report: InsertReport): Promise<Report> {\n+    const [created] = await db.insert(reports).values(report).returning();\n+    return created;\n+  }\n+\n+  // Admin/System\n+  async migrateUserId(oldId: string, newId: string): Promise<void> {\n+    console.warn(`Migrating user ${oldId} to ${newId} - Not fully implemented`);\n+  }\n+\n+  async updateReview(id: string, review: Partial<InsertReview>): Promise<Review | undefined> {\n+    const [updated] = await db\n+      .update(reviews)\n+      .set({ ...review, updatedAt: new Date() })\n+      .where(eq(reviews.id, id))\n+      .returning();\n+    if (updated) {\n+        this._invalidateRatingCache(updated.targetType, updated.targetId);\n+    }\n+    return updated;\n+  }\n+\n+  async deleteReview(id: string): Promise<boolean> {\n+    const [deleted] = await db\n+      .delete(reviews)\n+      .where(eq(reviews.id, id))\n+      .returning();\n+    if (deleted) {\n+      this._invalidateRatingCache(deleted.targetType, deleted.targetId);\n+    }\n+    return !!deleted;\n+  }\n+\n+  async getAverageRating(targetType: string, targetId: string): Promise<{ average: number; count: number }> {\n+    const key = `${targetType}|${targetId}`;\n+    const cached = this._ratingCache.get(key);\n+    if (cached && Date.now() - cached.timestamp < this._CACHE_TTL) {\n+      return cached.data;\n+    }\n+\n+    const result = await db\n+      .select({\n+        average: sql<number>`avg(${reviews.rating})::float`,\n+        count: sql<number>`count(*)::int`,\n+      })\n+      .from(reviews)\n+      .where(and(eq(reviews.targetType, targetType), eq(reviews.targetId, targetId)));\n+\n+    const data = {\n+      average: result[0]?.average || 0,\n+      count: result[0]?.count || 0,\n+    };\n+\n+    if (this._ratingCache.size >= this._CACHE_MAX_SIZE) {\n+      this._ratingCache.clear();\n+    }","path":"server/storage.ts","commit_id":"b8781ca50667611df17c5261d31707dc6ec8f7d8","original_commit_id":"b8781ca50667611df17c5261d31707dc6ec8f7d8","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_üßπ Nitpick_ | _üîµ Trivial_\n\n**Consider LRU eviction instead of clearing the entire cache.**\n\nClearing the entire cache when it reaches capacity could cause a thundering herd effect where many requests simultaneously hit the database to repopulate the cache. Consider implementing LRU eviction to remove only the oldest entries.\n\n\n<details>\n<summary>‚ôªÔ∏è Suggested improvement with partial eviction</summary>\n\n```diff\n    if (this._ratingCache.size >= this._CACHE_MAX_SIZE) {\n-     this._ratingCache.clear();\n+     // Evict oldest 25% of entries based on timestamp\n+     const entries = Array.from(this._ratingCache.entries())\n+       .sort((a, b) => a[1].timestamp - b[1].timestamp);\n+     const toRemove = Math.floor(entries.length * 0.25);\n+     for (let i = 0; i < toRemove; i++) {\n+       this._ratingCache.delete(entries[i][0]);\n+     }\n    }\n```\n</details>\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 1050 - 1052, The current logic clears the\nentire cache when this._ratingCache.size >= this._CACHE_MAX_SIZE causing a\nthundering herd; replace the full clear with an LRU eviction policy: when adding\na new rating and size >= this._CACHE_MAX_SIZE, remove the least-recently-used\nentry from this._ratingCache instead of calling this._ratingCache.clear();\nupdate accesses to the cache (reads/writes in the methods that use\nthis._ratingCache) to mark entries as recently used (e.g., move key to\nmost-recent position) or swap in a small LRU helper (or use an LRU cache\nlibrary) so that eviction targets only the oldest entry while preserving hot\nentries; keep the same _CACHE_MAX_SIZE constant and ensure eviction happens\nbefore inserting the new entry.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:ocelot -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T02:03:08Z","updated_at":"2026-01-28T02:03:09Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/89#discussion_r2734543529","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/89","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543529"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/89#discussion_r2734543529"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/89"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734543529/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":1050,"original_start_line":1050,"start_side":"RIGHT","line":1052,"original_line":1052,"side":"RIGHT","author_association":"NONE","original_position":165,"position":165,"subject_type":"line"}]
