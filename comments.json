[{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390084","pull_request_review_id":3714100869,"id":2734390084,"node_id":"PRRC_kwDOQmxOz86i-3tE","diff_hunk":"@@ -887,4 +889,183 @@ export class DatabaseStorage implements IStorage {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n \n-    if (filters.location) {\n\\ No newline at end of file\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;","path":"server/storage.ts","commit_id":"a7413ea2b38885cbd91fc6c19ac62bce8f07609b","original_commit_id":"f93dcc6268b974010a8ceba8749f9f8da390e077","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Implement the `today` date preset (or reject it explicitly).**\n\n`GigFilters.date` documents `today`, but the current logic only handles `upcoming` and `past`, so `today` falls through and returns unfiltered results. Add a bounded ‚Äútoday‚Äù range or validate/throw on unsupported values.  \n\n\n<details>\n<summary>üêõ Suggested fix (handle \"today\" + reject unknown values)</summary>\n\n```diff\n-    if (filters?.date && filters.date !== 'all') {\n+    if (filters?.date && filters.date !== 'all') {\n       const now = new Date();\n       if (filters.date === 'upcoming') {\n         conditions.push(gte(gigs.date, now));\n       } else if (filters.date === 'past') {\n         conditions.push(lt(gigs.date, now));\n+      } else if (filters.date === 'today') {\n+        const start = new Date(now);\n+        start.setHours(0, 0, 0, 0);\n+        const end = new Date(now);\n+        end.setHours(23, 59, 59, 999);\n+        conditions.push(gte(gigs.date, start));\n+        conditions.push(lte(gigs.date, end));\n+      } else {\n+        throw new Error(`Unsupported date filter: ${filters.date}`);\n       }\n     }\n```\n</details>\n\nAs per coding guidelines, All user inputs MUST be validated and sanitised.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n    if (filters?.location) {\n      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n    }\n    if (filters?.date && filters.date !== 'all') {\n      const now = new Date();\n      if (filters.date === 'upcoming') {\n        conditions.push(gte(gigs.date, now));\n      } else if (filters.date === 'past') {\n        conditions.push(lt(gigs.date, now));\n      } else if (filters.date === 'today') {\n        const start = new Date(now);\n        start.setHours(0, 0, 0, 0);\n        const end = new Date(now);\n        end.setHours(23, 59, 59, 999);\n        conditions.push(gte(gigs.date, start));\n        conditions.push(lte(gigs.date, end));\n      } else {\n        throw new Error(`Unsupported date filter: ${filters.date}`);\n      }\n    }\n    if (filters?.genre) {\n      conditions.push(eq(gigs.genre, filters.genre));\n    }\n    if (filters?.bandId) {\n      conditions.push(eq(gigs.bandId, filters.bandId));\n    }\n    if (filters?.searchQuery) {\n      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n      conditions.push(or(\n        ilike(gigs.title, query),\n        ilike(gigs.description, query),\n        ilike(gigs.location, query)\n      )!);\n    }\n    return conditions;\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 892 - 917, The date branch must handle the\ndocumented \"today\" preset and reject unknown values; inside the same method that\nbuilds SQL conditions (the block referencing gigs, _escapeLikeString and\nGigFilters.date) add an explicit filters.date === 'today' case that computes\nstartOfDay = new Date(now).setHours(0,0,0,0) and startOfNextDay = new\nDate(startOfDay + 24*60*60*1000) (or equivalent Date math) and push\ngte(gigs.date, startOfDay) and lt(gigs.date, startOfNextDay); keep the existing\nupcoming/past branches; finally add an else branch after those that\nthrows/returns a validation error for any non-'all'/'upcoming'/'past'/'today'\nvalue to reject unknown inputs.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T00:46:27Z","updated_at":"2026-01-28T00:46:28Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390084","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390084"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390084"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390084/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":892,"original_start_line":892,"start_side":"RIGHT","line":917,"original_line":917,"side":"RIGHT","author_association":"NONE","original_position":48,"position":48,"subject_type":"line"},{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390092","pull_request_review_id":3714100869,"id":2734390092,"node_id":"PRRC_kwDOQmxOz86i-3tM","diff_hunk":"@@ -887,4 +889,183 @@ export class DatabaseStorage implements IStorage {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n \n-    if (filters.location) {\n\\ No newline at end of file\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }","path":"server/storage.ts","commit_id":"a7413ea2b38885cbd91fc6c19ac62bce8f07609b","original_commit_id":"f93dcc6268b974010a8ceba8749f9f8da390e077","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Add try/catch + contextual logging around the DB call.**\n\nThis async method currently allows errors to bubble without context.  \n\n\n<details>\n<summary>üîß Suggested pattern</summary>\n\n```diff\n   async getGigsByBand(bandId: string): Promise<Gig[]> {\n-    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+    try {\n+      return await db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+    } catch (err) {\n+      console.error(\"getGigsByBand failed\", { bandId, err });\n+      throw err;\n+    }\n   }\n```\n</details>\n\nAs per coding guidelines, Every async function has try/catch error handling; Log errors with context.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  async getGigsByBand(bandId: string): Promise<Gig[]> {\n    try {\n      return await db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n    } catch (err) {\n      console.error(\"getGigsByBand failed\", { bandId, err });\n      throw err;\n    }\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 920 - 922, Wrap the DB call in getGigsByBand\nwith a try/catch: call db.select().from(gigs).where(eq(gigs.bandId,\nbandId)).orderBy(gigs.date) inside try, and in catch log a contextual error\nincluding the bandId and the error (use the module logger, e.g., processLogger\nor logger) then rethrow the error (or throw a wrapped Error) so callers still\nsee failure; ensure you reference getGigsByBand, gigs, db.select,\neq(gigs.bandId), and orderBy(gigs.date) so the change is applied to the correct\ncode.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T00:46:27Z","updated_at":"2026-01-28T00:46:28Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390092","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390092"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390092"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390092/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":920,"original_start_line":920,"start_side":"RIGHT","line":922,"original_line":922,"side":"RIGHT","author_association":"NONE","original_position":53,"position":53,"subject_type":"line"},{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390097","pull_request_review_id":3714100869,"id":2734390097,"node_id":"PRRC_kwDOQmxOz86i-3tR","diff_hunk":"@@ -887,4 +889,183 @@ export class DatabaseStorage implements IStorage {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n \n-    if (filters.location) {\n\\ No newline at end of file\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }\n+\n+  async getGigsByMusician(musicianId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.musicianId, musicianId)).orderBy(gigs.date);\n+  }\n+\n+  // Notifications\n+  async getNotifications(userId: string): Promise<Notification[]> {\n+    return db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));\n+  }\n+\n+  async getUnreadNotificationCount(userId: string): Promise<number> {\n+    const result = await db.select({ count: sql<number>`count(*)::int` }).from(notifications).where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));\n+    return result[0]?.count || 0;\n+  }\n+\n+  async createNotification(notification: InsertNotification): Promise<Notification> {\n+    const [created] = await db.insert(notifications).values(notification).returning();\n+    return created;\n+  }\n+\n+  async markNotificationAsRead(id: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));\n+  }\n+\n+  async markAllNotificationsAsRead(userId: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.userId, userId));\n+  }\n+\n+  // Contact Requests\n+  async createContactRequest(request: InsertContactRequest): Promise<ContactRequest> {\n+    const [created] = await db.insert(contactRequests).values(request).returning();\n+    return created;\n+  }\n+\n+  async getContactRequest(requesterId: string, recipientId: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(and(eq(contactRequests.requesterId, requesterId), eq(contactRequests.recipientId, recipientId)));\n+    return request;\n+  }\n+\n+  async getContactRequestById(id: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(eq(contactRequests.id, id));\n+    return request;\n+  }\n+  \n+  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+  }","path":"server/storage.ts","commit_id":"a7413ea2b38885cbd91fc6c19ac62bce8f07609b","original_commit_id":"f93dcc6268b974010a8ceba8749f9f8da390e077","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Validate contact request status before update.**\n\n`status` is currently any string, which allows invalid state transitions and breaks invariants.  \n\n\n<details>\n<summary>‚úÖ Suggested fix (validate + log)</summary>\n\n```diff\n   async updateContactRequestStatus(id: string, status: string): Promise<void> {\n-      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+      const allowed = new Set([\"pending\", \"accepted\", \"declined\"]);\n+      if (!allowed.has(status)) {\n+        throw new Error(`Invalid contact request status: ${status}`);\n+      }\n+      try {\n+        await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+      } catch (err) {\n+        console.error(\"updateContactRequestStatus failed\", { id, status, err });\n+        throw err;\n+      }\n   }\n```\n</details>\n\nAs per coding guidelines, All user inputs MUST be validated and sanitised; Every async function has try/catch error handling; Log errors with context.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 967 - 969, The updateContactRequestStatus\nfunction currently accepts any string; restrict allowed values by validating the\nstatus against an explicit set of permitted statuses (e.g., an array or enum of\nvalid states) before calling db.update on contactRequests, and if invalid throw\nor return a controlled error; wrap the DB operation in try/catch, log errors via\nthe existing logger with contextual info (id and attempted status) and rethrow\nor return a failure as per project conventions; ensure the validation and\nlogging are implemented inside updateContactRequestStatus so invalid or\nunexpected state transitions are prevented.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T00:46:27Z","updated_at":"2026-01-28T00:46:28Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390097","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390097"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390097"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390097/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":967,"original_start_line":967,"start_side":"RIGHT","line":969,"original_line":969,"side":"RIGHT","author_association":"NONE","original_position":100,"position":100,"subject_type":"line"},{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390100","pull_request_review_id":3714100869,"id":2734390100,"node_id":"PRRC_kwDOQmxOz86i-3tU","diff_hunk":"@@ -887,4 +889,183 @@ export class DatabaseStorage implements IStorage {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n \n-    if (filters.location) {\n\\ No newline at end of file\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }\n+\n+  async getGigsByMusician(musicianId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.musicianId, musicianId)).orderBy(gigs.date);\n+  }\n+\n+  // Notifications\n+  async getNotifications(userId: string): Promise<Notification[]> {\n+    return db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));\n+  }\n+\n+  async getUnreadNotificationCount(userId: string): Promise<number> {\n+    const result = await db.select({ count: sql<number>`count(*)::int` }).from(notifications).where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));\n+    return result[0]?.count || 0;\n+  }\n+\n+  async createNotification(notification: InsertNotification): Promise<Notification> {\n+    const [created] = await db.insert(notifications).values(notification).returning();\n+    return created;\n+  }\n+\n+  async markNotificationAsRead(id: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));\n+  }\n+\n+  async markAllNotificationsAsRead(userId: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.userId, userId));\n+  }\n+\n+  // Contact Requests\n+  async createContactRequest(request: InsertContactRequest): Promise<ContactRequest> {\n+    const [created] = await db.insert(contactRequests).values(request).returning();\n+    return created;\n+  }\n+\n+  async getContactRequest(requesterId: string, recipientId: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(and(eq(contactRequests.requesterId, requesterId), eq(contactRequests.recipientId, recipientId)));\n+    return request;\n+  }\n+\n+  async getContactRequestById(id: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(eq(contactRequests.id, id));\n+    return request;\n+  }\n+  \n+  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+  }\n+\n+  // Security\n+  async checkRateLimit(userId: string, type: string, limit: number, windowSeconds: number): Promise<boolean> {\n+    const now = new Date();\n+    const windowStart = new Date(now.getTime() - windowSeconds * 1000);\n+\n+    const [record] = await db\n+      .insert(rateLimits)\n+      .values({\n+        userId,\n+        type,\n+        hits: 1,\n+        windowStart: now,\n+      })\n+      .onConflictDoUpdate({\n+        target: [rateLimits.userId, rateLimits.type],\n+        set: {\n+          hits: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.hits + 1 ELSE 1 END`,\n+          windowStart: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.window_start ELSE ${now} END`,\n+        },\n+      })\n+      .returning();\n+\n+    return record.hits <= limit;\n+  }","path":"server/storage.ts","commit_id":"a7413ea2b38885cbd91fc6c19ac62bce8f07609b","original_commit_id":"f93dcc6268b974010a8ceba8749f9f8da390e077","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Guard invalid rate-limit inputs and add error handling.**\n\n`limit` or `windowSeconds` <= 0 yields undefined behavior (or accidental allow-all/deny-all).  \n\n\n<details>\n<summary>‚úÖ Suggested fix (validate + log)</summary>\n\n```diff\n   async checkRateLimit(userId: string, type: string, limit: number, windowSeconds: number): Promise<boolean> {\n+    if (limit <= 0 || windowSeconds <= 0) {\n+      throw new Error(`Invalid rate limit params: limit=${limit}, windowSeconds=${windowSeconds}`);\n+    }\n     const now = new Date();\n     const windowStart = new Date(now.getTime() - windowSeconds * 1000);\n \n-    const [record] = await db\n-      .insert(rateLimits)\n-      .values({\n-        userId,\n-        type,\n-        hits: 1,\n-        windowStart: now,\n-      })\n-      .onConflictDoUpdate({\n-        target: [rateLimits.userId, rateLimits.type],\n-        set: {\n-          hits: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.hits + 1 ELSE 1 END`,\n-          windowStart: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.window_start ELSE ${now} END`,\n-        },\n-      })\n-      .returning();\n+    try {\n+      const [record] = await db\n+        .insert(rateLimits)\n+        .values({\n+          userId,\n+          type,\n+          hits: 1,\n+          windowStart: now,\n+        })\n+        .onConflictDoUpdate({\n+          target: [rateLimits.userId, rateLimits.type],\n+          set: {\n+            hits: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.hits + 1 ELSE 1 END`,\n+            windowStart: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.window_start ELSE ${now} END`,\n+          },\n+        })\n+        .returning();\n \n-    return record.hits <= limit;\n+      return record.hits <= limit;\n+    } catch (err) {\n+      console.error(\"checkRateLimit failed\", { userId, type, limit, windowSeconds, err });\n+      throw err;\n+    }\n   }\n```\n</details>\n\nAs per coding guidelines, All user inputs MUST be validated and sanitised; Every async function has try/catch error handling; Log errors with context.\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 972 - 994, The checkRateLimit function\ncurrently accepts invalid inputs and has no error handling; add input validation\nat the top of checkRateLimit to reject or throw when limit <= 0 or windowSeconds\n<= 0 (check the limit and windowSeconds params), then wrap the DB\ninsert/onConflict/returning block (the\ndb.insert(rateLimits)...onConflictDoUpdate(...).returning() call) in a\ntry/catch, log errors with context (include userId, type, limit, windowSeconds)\nand rethrow or return a safe default (e.g., false) on failure; ensure logs\nreference the function name checkRateLimit and the rateLimits operation so\ndebugging is clear.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T00:46:27Z","updated_at":"2026-01-28T00:46:28Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390100","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390100"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390100"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390100/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":972,"original_start_line":972,"start_side":"RIGHT","line":994,"original_line":994,"side":"RIGHT","author_association":"NONE","original_position":125,"position":125,"subject_type":"line"},{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390103","pull_request_review_id":3714100869,"id":2734390103,"node_id":"PRRC_kwDOQmxOz86i-3tX","diff_hunk":"@@ -887,4 +889,183 @@ export class DatabaseStorage implements IStorage {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n \n-    if (filters.location) {\n\\ No newline at end of file\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }\n+\n+  async getGigsByMusician(musicianId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.musicianId, musicianId)).orderBy(gigs.date);\n+  }\n+\n+  // Notifications\n+  async getNotifications(userId: string): Promise<Notification[]> {\n+    return db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));\n+  }\n+\n+  async getUnreadNotificationCount(userId: string): Promise<number> {\n+    const result = await db.select({ count: sql<number>`count(*)::int` }).from(notifications).where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));\n+    return result[0]?.count || 0;\n+  }\n+\n+  async createNotification(notification: InsertNotification): Promise<Notification> {\n+    const [created] = await db.insert(notifications).values(notification).returning();\n+    return created;\n+  }\n+\n+  async markNotificationAsRead(id: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));\n+  }\n+\n+  async markAllNotificationsAsRead(userId: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.userId, userId));\n+  }\n+\n+  // Contact Requests\n+  async createContactRequest(request: InsertContactRequest): Promise<ContactRequest> {\n+    const [created] = await db.insert(contactRequests).values(request).returning();\n+    return created;\n+  }\n+\n+  async getContactRequest(requesterId: string, recipientId: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(and(eq(contactRequests.requesterId, requesterId), eq(contactRequests.recipientId, recipientId)));\n+    return request;\n+  }\n+\n+  async getContactRequestById(id: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(eq(contactRequests.id, id));\n+    return request;\n+  }\n+  \n+  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+  }\n+\n+  // Security\n+  async checkRateLimit(userId: string, type: string, limit: number, windowSeconds: number): Promise<boolean> {\n+    const now = new Date();\n+    const windowStart = new Date(now.getTime() - windowSeconds * 1000);\n+\n+    const [record] = await db\n+      .insert(rateLimits)\n+      .values({\n+        userId,\n+        type,\n+        hits: 1,\n+        windowStart: now,\n+      })\n+      .onConflictDoUpdate({\n+        target: [rateLimits.userId, rateLimits.type],\n+        set: {\n+          hits: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.hits + 1 ELSE 1 END`,\n+          windowStart: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.window_start ELSE ${now} END`,\n+        },\n+      })\n+      .returning();\n+\n+    return record.hits <= limit;\n+  }\n+\n+  // Reports\n+  async createReport(report: InsertReport): Promise<Report> {\n+    const [created] = await db.insert(reports).values(report).returning();\n+    return created;\n+  }\n+\n+  // Admin/System\n+  async migrateUserId(oldId: string, newId: string): Promise<void> {\n+    console.warn(`Migrating user ${oldId} to ${newId} - Not fully implemented`);\n+  }","path":"server/storage.ts","commit_id":"a7413ea2b38885cbd91fc6c19ac62bce8f07609b","original_commit_id":"f93dcc6268b974010a8ceba8749f9f8da390e077","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Don‚Äôt leave `migrateUserId` as a silent no-op.**\n\nA warn-only stub can mislead callers into assuming migration succeeded. Fail fast or implement fully.  \n\n\n<details>\n<summary>‚úÖ Safer default (fail fast)</summary>\n\n```diff\n   async migrateUserId(oldId: string, newId: string): Promise<void> {\n-    console.warn(`Migrating user ${oldId} to ${newId} - Not fully implemented`);\n+    throw new Error(`migrateUserId not implemented: ${oldId} -> ${newId}`);\n   }\n```\n</details>\n\nAs per coding guidelines, Every async function has try/catch error handling; Log errors with context.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  async migrateUserId(oldId: string, newId: string): Promise<void> {\n    throw new Error(`migrateUserId not implemented: ${oldId} -> ${newId}`);\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 1003 - 1005, The migrateUserId function is\ncurrently a silent no-op emitting only a console.warn; replace this with a\nproper failing or implemented migration path: inside migrateUserId (in\nserver/storage.ts) either implement the user-id migration logic or immediately\nthrow a descriptive Error (e.g., \"migrateUserId not implemented for oldId ->\nnewId\") so callers fail fast; ensure the async function wraps operations in\ntry/catch and uses the module logger (not console.warn) to log errors with\ncontextual info (oldId/newId and operation) before rethrowing, so callers\nreceive a clear failure and logs contain useful debugging context.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T00:46:27Z","updated_at":"2026-01-28T00:46:29Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390103","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390103"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390103"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390103/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":1003,"original_start_line":1003,"start_side":"RIGHT","line":1005,"original_line":1005,"side":"RIGHT","author_association":"NONE","original_position":136,"position":136,"subject_type":"line"},{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390112","pull_request_review_id":3714100869,"id":2734390112,"node_id":"PRRC_kwDOQmxOz86i-3tg","diff_hunk":"@@ -887,4 +889,183 @@ export class DatabaseStorage implements IStorage {\n     const conditions: any[] = [];\n     if (!filters) return conditions;\n \n-    if (filters.location) {\n\\ No newline at end of file\n+    if (filters?.location) {\n+      conditions.push(ilike(gigs.location, `%${this._escapeLikeString(filters.location)}%`));\n+    }\n+    if (filters?.date && filters.date !== 'all') {\n+      const now = new Date();\n+      if (filters.date === 'upcoming') {\n+        conditions.push(gte(gigs.date, now));\n+      } else if (filters.date === 'past') {\n+        conditions.push(lt(gigs.date, now));\n+      }\n+    }\n+    if (filters?.genre) {\n+      conditions.push(eq(gigs.genre, filters.genre));\n+    }\n+    if (filters?.bandId) {\n+      conditions.push(eq(gigs.bandId, filters.bandId));\n+    }\n+    if (filters?.searchQuery) {\n+      const query = `%${this._escapeLikeString(filters.searchQuery)}%`;\n+      conditions.push(or(\n+        ilike(gigs.title, query),\n+        ilike(gigs.description, query),\n+        ilike(gigs.location, query)\n+      )!);\n+    }\n+    return conditions;\n+  }\n+\n+  async getGigsByBand(bandId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.bandId, bandId)).orderBy(gigs.date);\n+  }\n+\n+  async getGigsByMusician(musicianId: string): Promise<Gig[]> {\n+    return db.select().from(gigs).where(eq(gigs.musicianId, musicianId)).orderBy(gigs.date);\n+  }\n+\n+  // Notifications\n+  async getNotifications(userId: string): Promise<Notification[]> {\n+    return db.select().from(notifications).where(eq(notifications.userId, userId)).orderBy(desc(notifications.createdAt));\n+  }\n+\n+  async getUnreadNotificationCount(userId: string): Promise<number> {\n+    const result = await db.select({ count: sql<number>`count(*)::int` }).from(notifications).where(and(eq(notifications.userId, userId), eq(notifications.isRead, false)));\n+    return result[0]?.count || 0;\n+  }\n+\n+  async createNotification(notification: InsertNotification): Promise<Notification> {\n+    const [created] = await db.insert(notifications).values(notification).returning();\n+    return created;\n+  }\n+\n+  async markNotificationAsRead(id: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.id, id));\n+  }\n+\n+  async markAllNotificationsAsRead(userId: string): Promise<void> {\n+    await db.update(notifications).set({ isRead: true }).where(eq(notifications.userId, userId));\n+  }\n+\n+  // Contact Requests\n+  async createContactRequest(request: InsertContactRequest): Promise<ContactRequest> {\n+    const [created] = await db.insert(contactRequests).values(request).returning();\n+    return created;\n+  }\n+\n+  async getContactRequest(requesterId: string, recipientId: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(and(eq(contactRequests.requesterId, requesterId), eq(contactRequests.recipientId, recipientId)));\n+    return request;\n+  }\n+\n+  async getContactRequestById(id: string): Promise<ContactRequest | undefined> {\n+    const [request] = await db.select().from(contactRequests).where(eq(contactRequests.id, id));\n+    return request;\n+  }\n+  \n+  async updateContactRequestStatus(id: string, status: string): Promise<void> {\n+      await db.update(contactRequests).set({ status }).where(eq(contactRequests.id, id));\n+  }\n+\n+  // Security\n+  async checkRateLimit(userId: string, type: string, limit: number, windowSeconds: number): Promise<boolean> {\n+    const now = new Date();\n+    const windowStart = new Date(now.getTime() - windowSeconds * 1000);\n+\n+    const [record] = await db\n+      .insert(rateLimits)\n+      .values({\n+        userId,\n+        type,\n+        hits: 1,\n+        windowStart: now,\n+      })\n+      .onConflictDoUpdate({\n+        target: [rateLimits.userId, rateLimits.type],\n+        set: {\n+          hits: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.hits + 1 ELSE 1 END`,\n+          windowStart: sql`CASE WHEN rate_limits.window_start > ${windowStart} THEN rate_limits.window_start ELSE ${now} END`,\n+        },\n+      })\n+      .returning();\n+\n+    return record.hits <= limit;\n+  }\n+\n+  // Reports\n+  async createReport(report: InsertReport): Promise<Report> {\n+    const [created] = await db.insert(reports).values(report).returning();\n+    return created;\n+  }\n+\n+  // Admin/System\n+  async migrateUserId(oldId: string, newId: string): Promise<void> {\n+    console.warn(`Migrating user ${oldId} to ${newId} - Not fully implemented`);\n+  }\n+\n+  async updateReview(id: string, review: Partial<InsertReview>): Promise<Review | undefined> {\n+    const [updated] = await db\n+      .update(reviews)\n+      .set({ ...review, updatedAt: new Date() })\n+      .where(eq(reviews.id, id))\n+      .returning();\n+    if (updated) {\n+        this._invalidateRatingCache(updated.targetType, updated.targetId);\n+    }\n+    return updated;\n+  }","path":"server/storage.ts","commit_id":"a7413ea2b38885cbd91fc6c19ac62bce8f07609b","original_commit_id":"f93dcc6268b974010a8ceba8749f9f8da390e077","user":{"login":"coderabbitai[bot]","id":136622811,"node_id":"BOT_kgDOCCSy2w","avatar_url":"https://avatars.githubusercontent.com/in/347564?v=4","gravatar_id":"","url":"https://api.github.com/users/coderabbitai%5Bbot%5D","html_url":"https://github.com/apps/coderabbitai","followers_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/followers","following_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/following{/other_user}","gists_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/gists{/gist_id}","starred_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/subscriptions","organizations_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/orgs","repos_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/repos","events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/events{/privacy}","received_events_url":"https://api.github.com/users/coderabbitai%5Bbot%5D/received_events","type":"Bot","user_view_type":"public","site_admin":false},"body":"_‚ö†Ô∏è Potential issue_ | _üü† Major_\n\n**Prevent cache staleness and validate review updates.**\n\n`updateReview` allows changing `targetType/targetId`, which would leave the old target‚Äôs cache stale. Also validate rating bounds.  \n\n\n<details>\n<summary>‚úÖ Suggested fix (disallow target changes + validate rating + log)</summary>\n\n```diff\n   async updateReview(id: string, review: Partial<InsertReview>): Promise<Review | undefined> {\n-    const [updated] = await db\n-      .update(reviews)\n-      .set({ ...review, updatedAt: new Date() })\n-      .where(eq(reviews.id, id))\n-      .returning();\n+    const { targetType, targetId, rating, ...safeUpdate } = review;\n+    if (rating !== undefined && (rating < 1 || rating > 5)) {\n+      throw new Error(`Invalid rating: ${rating}`);\n+    }\n+    try {\n+      const [updated] = await db\n+        .update(reviews)\n+        .set({ ...safeUpdate, ...(rating !== undefined ? { rating } : {}), updatedAt: new Date() })\n+        .where(eq(reviews.id, id))\n+        .returning();\n     if (updated) {\n-        this._invalidateRatingCache(updated.targetType, updated.targetId);\n+      this._invalidateRatingCache(updated.targetType, updated.targetId);\n     }\n-    return updated;\n+      return updated;\n+    } catch (err) {\n+      console.error(\"updateReview failed\", { id, review, err });\n+      throw err;\n+    }\n   }\n```\n</details>\n\nAs per coding guidelines, All user inputs MUST be validated and sanitised; Every async function has try/catch error handling; Log errors with context.\n\n<!-- suggestion_start -->\n\n<details>\n<summary>üìù Committable suggestion</summary>\n\n> ‚ÄºÔ∏è **IMPORTANT**\n> Carefully review the code before committing. Ensure that it accurately replaces the highlighted code, contains no missing lines, and has no issues with indentation. Thoroughly test & benchmark the code to ensure it meets the requirements.\n\n```suggestion\n  async updateReview(id: string, review: Partial<InsertReview>): Promise<Review | undefined> {\n    const { targetType, targetId, rating, ...safeUpdate } = review;\n    if (rating !== undefined && (rating < 1 || rating > 5)) {\n      throw new Error(`Invalid rating: ${rating}`);\n    }\n    try {\n      const [updated] = await db\n        .update(reviews)\n        .set({ ...safeUpdate, ...(rating !== undefined ? { rating } : {}), updatedAt: new Date() })\n        .where(eq(reviews.id, id))\n        .returning();\n      if (updated) {\n        this._invalidateRatingCache(updated.targetType, updated.targetId);\n      }\n      return updated;\n    } catch (err) {\n      console.error(\"updateReview failed\", { id, review, err });\n      throw err;\n    }\n  }\n```\n\n</details>\n\n<!-- suggestion_end -->\n\n<details>\n<summary>ü§ñ Prompt for AI Agents</summary>\n\n```\nIn `@server/storage.ts` around lines 1007 - 1017, In updateReview, prevent\nchanging the review's target and validate rating bounds plus add error handling:\nfirst fetch the existing review (e.g., query reviews by id), compare its\ntargetType/targetId to the incoming review and reject/throw/log if they differ\n(do not allow target changes), validate rating (e.g., ensure review.rating is\nwithin allowed bounds like 1‚Äì5) before updating, wrap the DB update in try/catch\nand log any errors with context (include id and the review payload), and after a\nsuccessful update call this._invalidateRatingCache(updated.targetType,\nupdated.targetId) as before; refer to the updateReview method, InsertReview\ntype, reviews table, and _invalidateRatingCache to locate where to apply these\nchanges.\n```\n\n</details>\n\n<!-- fingerprinting:phantom:poseidon:eagle -->\n\n<!-- This is an auto-generated comment by CodeRabbit -->","created_at":"2026-01-28T00:46:27Z","updated_at":"2026-01-28T00:46:29Z","html_url":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390112","pull_request_url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88","_links":{"self":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390112"},"html":{"href":"https://github.com/HutchisonSorbo/smalltalk.community/pull/88#discussion_r2734390112"},"pull_request":{"href":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/88"}},"reactions":{"url":"https://api.github.com/repos/HutchisonSorbo/smalltalk.community/pulls/comments/2734390112/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"start_line":1007,"original_start_line":1007,"start_side":"RIGHT","line":1017,"original_line":1017,"side":"RIGHT","author_association":"NONE","original_position":148,"position":148,"subject_type":"line"}]